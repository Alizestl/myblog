<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Wireshark抓tcp包实践与深入了解存活机制 | Talk is cheap.</title>
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/ChineseMono-normal-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-italic-normal.min.css">
  <link rel="stylesheet" href="/css/fonts/Chinese-normal-bold.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="description" content="“八股还是得自己动手才记得住啊……准备冻手！准备冻手！”">
  
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
  
<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div id="nav-outer">
  <nav id="main-nav" class="outer">
    <a id="main-nav-toggle" class="nav-icon"></a>
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
    <div class="main-nav-space-between"></div>
    
  </nav>
</div>
<div id="header-title">
  <h1 id="logo-wrap">
    <a href="/" id="logo">Talk is cheap.</a>
  </h1>
  
</div>

      <div id="content" class="outer">
        <section id="main"><article id="post-wireshark_tcp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/15/wireshark_tcp/" class="article-date">
  <time class="dt-published" datetime="2025-03-15T15:15:02.000Z" itemprop="datePublished">2025-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Wireshark抓tcp包实践与深入了解存活机制
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近两次面试都有面试官看我简历上写的博客其实还挺高兴的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>然后想到最近春招面试被问到很多次TCP的八股题<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>今晚尝试用wireshark抓包看一看<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>也算是水一篇博客了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h1><p>尝试用wireshark抓本机访问公网的包发现<code>http.request.method == &quot;GET&quot;</code> 过滤后没有结果<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>忘了现在已经普及HTTPS了hhh<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>想明白这点后马上打开学校内网的教务系统<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>因为它没做HTTPS<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>再加上我Firefox设置了HTTPS严格模式<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>每次用我都要点一下<span class="bd-box"><h-char class="bd bd-end"><h-inner>【</h-inner></h-char></span>继续不安全访问<span class="bd-box"><h-char class="bd bd-beg"><h-inner>】</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这是我第一反应想到的HTTP网站hhh</p>
<p>但是其实看起来还挺吃力的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>索性就自己写个web服务看一下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webhook</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;TCP&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/webhook&quot;</span>, webhook)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Server on.&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Error: %v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Wireshark-配置-环回适配器"><a href="#Wireshark-配置-环回适配器" class="headerlink" title="Wireshark 配置 环回适配器"></a>Wireshark 配置 环回适配器</h1><p>因为webhook是在本地8080端口上运行的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>所以打开wireshark配置Capture Option 要选择为 <code>Adapter for loopback traffic capture</code><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>环回适配器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>Windows 内置的 <strong>环回适配器<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Loopback Pseudo-Interface<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>用于捕获 <strong>本机内部的网络流量</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 <a target="_blank" rel="noopener" href="https://localhost/">localhost</a> 通信<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>数据不经过物理网卡<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接在内核层转发<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/capture_option.png" alt="capture_option"></p>
<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>按照以下步骤开始抓包</p>
<ol>
<li><p>运行webhook服务</p>
</li>
<li><p>启动wireshark抓包</p>
</li>
<li><p>浏览器访问<code>localhost:8080</code></p>
</li>
</ol>
<p>此刻可以wireshark中抓到许多包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>输入以下过滤器语法来过滤数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>我这里多写了个and条件<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>直接筛选Info 列的<code>/webhook</code> api接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.request.method == GET &amp;&amp; frame contains &quot;webhook&quot;</span><br></pre></td></tr></table></figure>



<p>过滤后如下图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>这不比抓公网的包清楚<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/webhook.png" alt="webhook"></p>
<p>wireshark能够抓到多层网络协议的报文<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>由于我是在本地起的web服务<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>在配置wireshark的Capture Option时选择了<code>Adapter for loopback traffic capture</code><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>环回适配器<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如下图<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是没有链路层的报文的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>依次分别为Frame物理层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>链路层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>Internet Protocol网络层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>Transmission传输层<span class="bd-box"><h-char class="bd bd-beg"><h-inner>、</h-inner></h-char></span>明文数据<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/loopback.png" alt="loopback"></p>
<h1 id="TCP-流分析"><a href="#TCP-流分析" class="headerlink" title="TCP 流分析"></a>TCP 流分析</h1><p>选中第一个时间更早的数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>使用”Following TCP streams”功能跟踪tcp数据流</p>
<p><img src="/../images/wireshark_tcp/tcp_follow1.png" alt="tcp_follow1"></p>
<p>可以看到完整的TCP连接与关闭数据流<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/tcp_follow2.png" alt="tcp_follow2"></p>
<p>本质上”Following TCP streams”的功能<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>就是使用<code>tcp.stream eq xx</code>的过滤语法<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>xx</code>是具体的 TCP 流编号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>上图中 TCP 流编号是<code>56</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>Wireshark 会为每个 TCP 连接分配一个唯一的流编号<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span><code>tcp.stream</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>方便对不同的 TCP 连接进行区分和分析<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>如下图红框中<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>前三个数据包是TCP的握手数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看到明显的ACK SYN标志位和seq值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/tcp_link.png" alt="tcp_link"></p>
<p>第一个数据包<code>Seq=0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>客户端初始序列号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>第二个数据包<code>Info</code> 列显示 <code>[SYN, ACK]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示服务器确认客户端请求并同步自身序列号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><strong>确认号<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Ack<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>Ack=1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即确认客户端序列号 <code>Seq=0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>期望下一个包序列号为 <code>1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
<li><strong>序列号<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Seq<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>Seq=0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>服务器初始序列号<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></li>
</ul>
<p>第三个数据包<code>Info</code> 列显示 <code>[ACK]</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>表示客户端确认服务器响应<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li><p><strong>确认号<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Ack<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>Ack=1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>确认服务器序列号 <code>Seq=0</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
<li><p><strong>序列号<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Seq<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span><code>Seq=1</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>基于第一次握手的 <code>Seq=0</code> 递增<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
</li>
</ul>
<h2 id="TCP-存活探测-探讨与实践"><a href="#TCP-存活探测-探讨与实践" class="headerlink" title="TCP 存活探测 探讨与实践"></a>TCP 存活探测 探讨与实践</h2><p>TCP连接建立后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以看到后续是一些该TCP连接的存活探测数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即标有 <code>[TCP Keep-Alive]</code> 的数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>这些数据包在长达一分钟的时间能不断发送<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一分钟后TCP执行四次挥手断开连接<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p><strong>这里其实有个小的细节<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>以前一直没有注意<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>背八股也没有注意到<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></strong></p>
<p><code>[TCP Keep-Alive]</code> 的存活探测数据包发送多久时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>一方面是由<strong>系统层面的 TCP 保活机制</strong>确定保活参数<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<ul>
<li>linux下默认保活时间由 <code>net.ipv4.tcp_keepalive_time</code>参数决定<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>默认 2 小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
<li>win下由注册表参数决定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>可以查找对应注册表键值<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>也可以使用terminal命令快速查找<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>若没有设置<code>KeepAliveTime</code> 字段<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>则该字段值设为默认值7200000毫秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>即2小时<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></li>
</ul>
<p><img src="/../images/wireshark_tcp/tcp%E4%BF%9D%E6%B4%BB.png" alt="tcp保活"></p>
<p>既然知道了OS层面的保活时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>跟我们实际观测到的TCP保活时间是对不上的<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>实际保活时间只有1分钟<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>原因在于<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span><code>[TCP Keep-Alive]</code> 的存活探测数据包发送多久时间<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>另一方面还由<strong>HTTP 层的长连接机制</strong>决定<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>而浏览器默认启用 <code>Connection: keep-alive</code><span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>空闲超时通常为 <strong>1 分钟</strong><span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>如 IE&#x2F;Edge 注册表默认值 <code>KeepAliveTimeout=60000</code> 毫秒<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>虽然我都背过计网经典八股 – <code>HTTP/1.1</code>版本支持长连接了<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>但具体实践过后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>才能有更加深刻的印象……</p>
<h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>拉到整个TCP流的最后<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>是TCP的挥手包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>如下图所示<span class="bd-box"><h-char class="bd bd-beg"><h-inner>：</h-inner></h-char></span></p>
<p><img src="/../images/wireshark_tcp/tcp_unlink.png" alt="tcp_unlink"></p>
<p>注意看最后哦6条数据包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>其中两行黑色的根据<code>[TCP Dup ACK xxx#y]</code> 标签可以判断是之前xxx号包的第y次 <strong>重复的 TCP 确认报文<span class="bd-box"><h-char class="bd bd-end"><h-inner>（</h-inner></h-char></span>Duplicate ACK<span class="bd-box"><h-char class="bd bd-beg"><h-inner>）</h-inner></h-char></span></strong><span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span>剩下四行是<code>56</code>流编号TCP连接的四次挥手包<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>可以很明显地看到八股吟唱中的常见语句<code>[FIN ACK]</code> 标签<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>各个包的Seq值与其后续包的Ack值也能对上<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>本次实践源于等腾讯三面心太累<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>又不想背八股<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>索性找点事情玩玩<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>
<p>Just for fun.</p>
<p>如能给一些朋友作为参考帮助<span class="bd-box"><h-char class="bd bd-beg"><h-inner>，</h-inner></h-char></span>不甚荣幸<span class="bd-box"><h-char class="bd bd-beg"><h-inner>。</h-inner></h-char></span></p>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tech/" rel="tag">Tech</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/23/before_graudate_of_ba/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          记毕业前的半年
        
      </div>
    </a>
  
  
    <a href="/2025/01/28/Troubleshooting-an-infinite-redirect-error/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Troubleshooting an infinite redirect error
        
      </div>
    </a>
  
</nav>

  
</article>


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
        <p></p>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>






<script>
  MathJax = {
    options: {
      enableMenu: false
    },
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
    }
  };
</script>
<!-- <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
    CommonHTML: {
      linebreaks: false
    }
  });
  </script> -->
<script type="text/javascript" id="MathJax-script" async
  src="/mathjax/tex-chtml.js">
</script>
<!-- <script type="text/javascript"
   src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_CHTML">
</script> -->

  </div>
</body>
</html>